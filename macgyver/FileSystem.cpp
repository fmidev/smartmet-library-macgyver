#include "FileSystem.h"
#include <chrono>
#include <istream>
#include <optional>
#include <ostream>
#include <random>
#include <filesystem>
#include <sys/stat.h>
#include <boost/iostreams/filtering_stream.hpp>
#include "Exception.h"

#include <boost/iostreams/filter/bzip2.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#ifndef WIN32
#include <boost/iostreams/filter/lzma.hpp>
#include <boost/iostreams/filter/zstd.hpp>
#endif

namespace fs = std::filesystem;

std::time_t
Fmi::last_write_time(const fs::path& path, std::error_code& ec)
{
    const char* fn = path.c_str();
    struct stat st;
    if (stat(fn, &st) == 0)
    {
        ec = std::error_code();
        return st.st_mtime;
    }

    ec = std::error_code(errno, std::system_category());
    return 0;
}

std::time_t Fmi::last_write_time(const fs::path& path)
{
    std::error_code ec;
    const std::time_t t = Fmi::last_write_time(path, ec);
    if (ec)
    {
        Fmi::Exception exception(BCP, "Failed to get last write time");
        exception.addParameter("Path", path.string());
        exception.addDetail(ec.message());
        throw exception;
    }
    return t;
}

std::time_t Fmi::last_write_time_or(const fs::path& path, const std::time_t default_time)
{
    std::error_code ec;
    const std::time_t t = Fmi::last_write_time(path, ec);
    if (ec)
    {
        return default_time;
    }
    return t;
}

// Function to generate a unique path similar to boost::filesystem::unique_path
// (based on version generated by ChatGPT 4o)
fs::path Fmi::unique_path(const fs::path& model)
{
    const int max_tries = 1024;
    std::string result;
    result.reserve(model.string().size());

    int num_tries = 0;

    auto random_char = []() -> char {
        constexpr char charset[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        constexpr std::size_t max_index = sizeof(charset) - 1;
        std::mt19937 generator(std::random_device{}());
        std::uniform_int_distribution<> distribution(0, max_index);
        return charset[distribution(generator)];
    };

    do {
        result.clear();
        for (const char c : model.string()) {
            if (c == '%') {
                result += random_char();
            } else {
                result += c;
            }
        }

        if (num_tries > max_tries)
        {
            throw Fmi::Exception(BCP, "Failed to generate unique path - too many tries");
        }
    } while (fs::exists(result));

    return fs::path(result);
}

enum Fmi::Compression Fmi::guess_compression_type(const std::string& theFileName)
{
    auto pos = theFileName.rfind('.');
    if (pos == std::string::npos)
        return Compression::NONE;

    const char* ext = theFileName.c_str() + pos + 1;

    if (strcasecmp(ext, "bz2") == 0)
        return Compression::BZIP2;

    if (strcasecmp(ext, "gz") == 0)
        return Compression::GZIP;
#ifndef WIN32
    if (strcasecmp(ext, "zstd") == 0)
        return Compression::ZSTD;

    if (strcasecmp(ext, "xz") == 0)
        return Compression::XZ;
#endif
    return Compression::NONE;
}

std::optional<std::string> Fmi::lookup_file(const std::string& theFileName)
{
    std::optional<std::string> result;

    const auto check_fn = [](const std::string& fn) -> bool
        {
            std::error_code ec;
            return fs::exists(fn, ec)
                && (fs::is_regular_file(fn, ec) || fs::is_symlink(fn, ec));
        };

    if (check_fn(theFileName))
        return std::optional<std::string>(theFileName);

    if (Fmi::guess_compression_type(theFileName) == Fmi::Compression::NONE)
    {
        static std::vector<std::string> extensions =
            {
                ".gz"
                , ".bz2"
#ifndef WIN32
                , ".xz"
                , ".zstd"
#endif
            };
        for (const auto& ext : extensions)
        {
            const std::string zfn = theFileName + ext;
            if (check_fn(zfn))
                return std::optional<std::string>(zfn);
        }
    }

    return std::optional<std::string>();
}

Fmi::IStream::IStream(std::istream& raw_input, const std::string& name)
    : boost::iostreams::filtering_stream<boost::iostreams::input>()
{
    init(raw_input, guess_compression_type(name));
}

Fmi::IStream::IStream(std::istream& raw_input, Compression compression)
{
    init(raw_input, compression);
}

void Fmi::IStream::init(std::istream& raw_input, Compression compression)
{
    switch (compression)
    {
    default:
    case Compression::NONE:
        break;

    case Compression::GZIP:
        push(boost::iostreams::gzip_decompressor());
        break;

    case Compression::BZIP2:
        push(boost::iostreams::bzip2_decompressor());
        break;

#ifndef WIN32
    case Compression::ZSTD:
        push(boost::iostreams::zstd_decompressor());
        break;

    case Compression::XZ:
        push(boost::iostreams::lzma_decompressor());
        break;
    }
#endif
    push(raw_input);
}

Fmi::OStream::OStream(std::ostream& raw_output, const std::string& name)
    : boost::iostreams::filtering_stream<boost::iostreams::output>()
{
    init(raw_output, guess_compression_type(name));
}

Fmi::OStream::OStream(std::ostream& raw_output, Compression compression)
{
    init(raw_output, compression);
}

void Fmi::OStream::init(std::ostream& raw_output, Compression compression)
{
    switch (compression)
    {
    default:
    case Compression::NONE:
        break;

    case Compression::GZIP:
        push(boost::iostreams::gzip_compressor());
        break;

    case Compression::BZIP2:
        push(boost::iostreams::bzip2_compressor());
        break;

#ifndef WIN32
    case Compression::ZSTD:
        push(boost::iostreams::zstd_compressor());
        break;

    case Compression::XZ:
        push(boost::iostreams::lzma_compressor());
        break;
    }
#endif
    push(raw_output);
}
